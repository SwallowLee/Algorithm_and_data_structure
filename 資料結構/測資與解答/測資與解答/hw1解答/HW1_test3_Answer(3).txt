test3.txt

2 30 "efi" "from the given sequences. TPrefixSpan algorithm finds the relevant frequent patterns "
2 24 "s." "from the given sequences. TPrefixSpan algorithm finds the relevant frequent patterns "
2 27 "tpre" "from the given sequences. TPrefixSpan algorithm finds the relevant frequent patterns "
3 69 "s." "from the given sequential patterns formed using interval based events. In our "
4 2 "rop" "proposed work, we add multiple constraints like item, length and aggregate to"
5 23 "efi" "the interval based TPrefixSpan algorithm. By adding these constraints the efficiency "
5 20 "tpre" "the interval based TPrefixSpan algorithm. By adding these constraints the efficiency "
6 51 "rop" "and effectiveness of the algorithm improves. The proposed constraint based "
6 43 "s." "and effectiveness of the algorithm improves. The proposed constraint based "
7 15 "efi" "algorithm CTPrefixSpan has been applied to synthetic medical dataset. The algorithm "
7 12 "tpre" "algorithm CTPrefixSpan has been applied to synthetic medical dataset. The algorithm "
8 55 "s a" "can be applied for stock market analysis, DNA sequences analysis etc."
9 31 "temp" "KEYWORDS Sequential patterns, temporal patterns, Constraints, Interval based "
10 6 "s." "events. 1. INTRODUCTION Data mining is useful in various domains such as market "
10 21 "ion" "events. 1. INTRODUCTION Data mining is useful in various domains such as market "
11 16 "ion" "analysis, decision support, fraud detection, business management and so on. "
11 41 "ion" "analysis, decision support, fraud detection, business management and so on. "
12 28 "s a" "Sequential pattern mining is an approach to extract information from input "
12 61 "ion" "Sequential pattern mining is an approach to extract information from input "
13 43 "rop" "sequences [1]. Various methods have been proposed for mining temporal"
13 62 "temp" "sequences [1]. Various methods have been proposed for mining temporal"
14 73 "s a" "patterns in sequence databases such as mining repetitive patterns, trends and "
15 49 "s a" "sequential patterns. Sequential Pattern Mining is a popular technique which consists "
15 19 "s." "sequential patterns. Sequential Pattern Mining is a popular technique which consists "
16 23 "s a" "of finding subsequences appearing frequently in a set of sequence. However, "
17 82 "s." "knowing that a sequence appear frequently is not sufficient for making predictions. "
17 79 "ion" "knowing that a sequence appear frequently is not sufficient for making predictions. "
18 36 "s a" "Sequential pattern mining approaches are classified as Apriori [2] or generate and "
18 54 "s a" "Sequential pattern mining approaches are classified as Apriori [2] or generate and "
20 45 "rop" "AprioriAll algorithms are based on apriori property and use the generate join"
20 21 "s a" "AprioriAll algorithms are based on apriori property and use the generate join"
23 62 "s a" "the database. Some of the widely used apriori based algorithms are GSP [3], SPADE "
24 43 "s a" "[4] and SPAM [5]. Pattern growth algorithms allow the frequent item set discovery "
25 35 "ion" "without candidate item set generation. They first build the data structure called "
26 71 "s a" "FP-tree. Frequent Pattern tree consists of nodes corresponding to items and counters. "
26 84 "s." "FP-tree. Frequent Pattern tree consists of nodes corresponding to items and counters. "
27 34 "ion" "This tree reads only one transaction at a time and maps it to a path. Then it extracts "
29 25 "efi" "growth Algorithms are PrefixSpan [6] and FreeSpan [7] . A projection based"
29 17 "s a" "growth Algorithms are PrefixSpan [6] and FreeSpan [7] . A projection based"
29 66 "ion" "growth Algorithms are PrefixSpan [6] and FreeSpan [7] . A projection based"
30 36 "efi" "pattern-growth method is used in PrefixSpan (Prefix-projected Sequential pattern "
30 48 "efi" "pattern-growth method is used in PrefixSpan (Prefix-projected Sequential pattern "
31 48 "s." "mining) algorithm for mining sequential patterns. Its major idea is that, instead of "
33 62 "efi" "frequent sub sequences, the projection is done on frequent prefix which results in "
33 36 "ion" "frequent sub sequences, the projection is done on frequent prefix which results in "
34 72 "efi" "higher efficiency of the algorithm in terms of processing time. The TPrefixSpan [8] "
34 69 "tpre" "higher efficiency of the algorithm in terms of processing time. The TPrefixSpan [8] "
35 80 "s." "algorithm is developed to mine the temporal patterns from interval- based events. "
35 36 "temp" "algorithm is developed to mine the temporal patterns from interval- based events. "
36 28 "efi" "Interval-based events are defined as the pair of time values associated with each"
36 21 "s a" "Interval-based events are defined as the pair of time values associated with each"
36 60 "s a" "Interval-based events are defined as the pair of time values associated with each"
37 8 "temp" "event. Temporal pattern mining includes various tasks like temporal pattern analysis "
37 60 "temp" "event. Temporal pattern mining includes various tasks like temporal pattern analysis "
38 17 "temp" "and comparison, temporal classification, temporal association rules, temporal "
38 42 "temp" "and comparison, temporal classification, temporal association rules, temporal "
38 70 "temp" "and comparison, temporal classification, temporal association rules, temporal "
38 37 "ion" "and comparison, temporal classification, temporal association rules, temporal "
38 59 "ion" "and comparison, temporal classification, temporal association rules, temporal "
39 44 "efi" "clustering and temporal prediction [9]. TPrefixSpan algorithm deals with mining "
39 16 "temp" "clustering and temporal prediction [9]. TPrefixSpan algorithm deals with mining "
39 32 "ion" "clustering and temporal prediction [9]. TPrefixSpan algorithm deals with mining "
39 41 "tpre" "clustering and temporal prediction [9]. TPrefixSpan algorithm deals with mining "
40 10 "temp" "frequent temporal patterns from interval based events in a given sequence database. "
41 64 "efi" "This paper discusses about adding multiple constraints with TPrefixSpan algorithm "
41 20 "s a" "This paper discusses about adding multiple constraints with TPrefixSpan algorithm "
41 61 "tpre" "This paper discusses about adding multiple constraints with TPrefixSpan algorithm "
42 39 "efi" "which increases the performance of TPrefixSpan algorithm and reduce the "
42 36 "tpre" "which increases the performance of TPrefixSpan algorithm and reduce the "
43 41 "efi" "computational time. Constraints based PrefixSpan algorithm discovers sequential"
43 9 "ion" "computational time. Constraints based PrefixSpan algorithm discovers sequential"
44 84 "s." "patterns which are frequent and also satisfy aggregate, length, and item constraints. "
45 46 "efi" "In this work, Constraint based algorithm CTPrefixSpan is proposed to discover "
45 59 "rop" "In this work, Constraint based algorithm CTPrefixSpan is proposed to discover "
45 43 "tpre" "In this work, Constraint based algorithm CTPrefixSpan is proposed to discover "
46 77 "s." "frequent temporal patterns considering item, length and aggregate constraints."
46 10 "temp" "frequent temporal patterns considering item, length and aggregate constraints."
47 54 "rop" "2. Literature survey In [4] R.Srikant and R.Agarwal proposed an algorithm called ¡§GSP¡¨ "
48 51 "s a" "(Generalized Sequential Pattern) algorithm which is an apriori based approach for "
49 73 "s a" "mining frequent patterns. SPAM: SPAM (Sequential Pattern Mining) [5] uses a vertical "
49 24 "s." "mining frequent patterns. SPAM: SPAM (Sequential Pattern Mining) [5] uses a vertical "
50 34 "ion" "bitmap data structure representation of database which is similar to the given id-list "
52 10 "s." "algorithms. FreeSpan [7] is the frequent pattern projected sequential pattern mining "
54 74 "s." "and uses the projected database to find the growth of subsequent fragments. Pie et "
55 10 "rop" "al. [6] proposed a projection based sequential pattern mining algorithm called "
55 27 "ion" "al. [6] proposed a projection based sequential pattern mining algorithm called "
56 3 "efi" "PrefixSpan algorithm (Prefix-projected Sequential Pattern mining), which mines the "
56 25 "efi" "PrefixSpan algorithm (Prefix-projected Sequential Pattern mining), which mines the "
57 63 "rop" "frequent patterns from a given data sequence. In [8] Wu-Chen proposed a "
58 62 "efi" "non-ambiguous temporal pattern for interval-based events. TPrefixSpan algorithm "
58 56 "s." "non-ambiguous temporal pattern for interval-based events. TPrefixSpan algorithm "
58 15 "temp" "non-ambiguous temporal pattern for interval-based events. TPrefixSpan algorithm "
58 59 "tpre" "non-ambiguous temporal pattern for interval-based events. TPrefixSpan algorithm "
59 6 "rop" "was proposed to mine the new kind of temporal pattern from interval based events. "
59 80 "s." "was proposed to mine the new kind of temporal pattern from interval based events. "
59 38 "temp" "was proposed to mine the new kind of temporal pattern from interval based events. "
60 67 "efi" "Irfan Khan [10] included multiple constraints with the existing PrefixSpan algorithm "
61 32 "efi" "to improve the efficiency of PrefixSpan algorithm. Similarly, to improve the efficiency"
62 7 "efi" "of TPrefixSpan algorithm constraints are included and CTPrefixSpan algorithm is "
62 59 "efi" "of TPrefixSpan algorithm constraints are included and CTPrefixSpan algorithm is "
62 36 "s a" "of TPrefixSpan algorithm constraints are included and CTPrefixSpan algorithm is "
62 4 "tpre" "of TPrefixSpan algorithm constraints are included and CTPrefixSpan algorithm is "
62 56 "tpre" "of TPrefixSpan algorithm constraints are included and CTPrefixSpan algorithm is "
63 2 "rop" "proposed in this work. 3. Existing system Interval-based events are represented by "
63 63 "s a" "proposed in this work. 3. Existing system Interval-based events are represented by "
64 14 "s." "two end points. The end point represent the start time and end time of the intervals. "
64 84 "s." "two end points. The end point represent the start time and end time of the intervals. "
65 8 "ion" "Projection method for interval-based events is different from that of point-based "
66 51 "efi" "events. This form of representation is used in TPrefixSpan algorithm. TPrefixSpan"
66 74 "efi" "events. This form of representation is used in TPrefixSpan algorithm. TPrefixSpan"
66 6 "s." "events. This form of representation is used in TPrefixSpan algorithm. TPrefixSpan"
66 33 "ion" "events. This form of representation is used in TPrefixSpan algorithm. TPrefixSpan"
66 48 "tpre" "events. This form of representation is used in TPrefixSpan algorithm. TPrefixSpan"
66 71 "tpre" "events. This form of representation is used in TPrefixSpan algorithm. TPrefixSpan"
67 28 "efi" "algorithm is slower than PrefixSpan algorithm as representing the interval based "
68 37 "efi" "events requires larger space. In TPrefixSpan algorithm, initially the length of the "
68 34 "tpre" "events requires larger space. In TPrefixSpan algorithm, initially the length of the "
69 55 "temp" "sequential pattern is found. Then the set of frequent temporal 1-patterns is found "
70 43 "s a" "from a given sequence database. These steps are repeated until the all frequent "
71 8 "s a" "patterns are found. All frequent patterns from the sequences are generated. In "
71 60 "s a" "patterns are found. All frequent patterns from the sequences are generated. In "
72 4 "efi" "TPrefixSpan algorithm ¡§Temporal Prefix¡¨, and ¡§Temporal Postfix¡¨ projected databases "
72 36 "efi" "TPrefixSpan algorithm ¡§Temporal Prefix¡¨, and ¡§Temporal Postfix¡¨ projected databases "
72 25 "temp" "TPrefixSpan algorithm ¡§Temporal Prefix¡¨, and ¡§Temporal Postfix¡¨ projected databases "
72 50 "temp" "TPrefixSpan algorithm ¡§Temporal Prefix¡¨, and ¡§Temporal Postfix¡¨ projected databases "
72 62 "tf" "TPrefixSpan algorithm ¡§Temporal Prefix¡¨, and ¡§Temporal Postfix¡¨ projected databases "
72 1 "tpre" "TPrefixSpan algorithm ¡§Temporal Prefix¡¨, and ¡§Temporal Postfix¡¨ projected databases "
73 26 "efi" "are to be found and the definitions are given below. The following 2 definitions are "
73 71 "efi" "are to be found and the definitions are given below. The following 2 definitions are "
73 35 "s a" "are to be found and the definitions are given below. The following 2 definitions are "
73 80 "s a" "are to be found and the definitions are given below. The following 2 definitions are "
73 32 "ion" "are to be found and the definitions are given below. The following 2 definitions are "
73 77 "ion" "are to be found and the definitions are given below. The following 2 definitions are "
74 15 "efi" "based on the definitions in [8]. 3.1 Definition: (Temporal prefix) 4. Proposed system "
74 39 "efi" "based on the definitions in [8]. 3.1 Definition: (Temporal prefix) 4. Proposed system "
74 62 "efi" "based on the definitions in [8]. 3.1 Definition: (Temporal prefix) 4. Proposed system "
74 72 "rop" "based on the definitions in [8]. 3.1 Definition: (Temporal prefix) 4. Proposed system "
74 51 "temp" "based on the definitions in [8]. 3.1 Definition: (Temporal prefix) 4. Proposed system "
74 21 "ion" "based on the definitions in [8]. 3.1 Definition: (Temporal prefix) 4. Proposed system "
74 45 "ion" "based on the definitions in [8]. 3.1 Definition: (Temporal prefix) 4. Proposed system "
75 46 "efi" "To improve the efficiency of the existing TPrefixSpan algorithm, we need to add more "
75 43 "tpre" "To improve the efficiency of the existing TPrefixSpan algorithm, we need to add more "
76 78 "s." "constraints like length, item and aggregate on the output of frequent patterns. "
79 81 "s." "the run time of finding frequent patterns from the given sequences will increases. "
82 57 "s a" "It decreases the patterns from relevant frequent patterns according to the input "
85 73 "s." "time of finding frequent patterns from the given sequences will increases. We can "
88 54 "s a" "decreases the patterns from relevant frequent patterns according to the input "
93 42 "efi" "support initially as 0.5. 4.1.2 Apply TPrefixSpan algorithm: To mine the frequent "
93 39 "tpre" "support initially as 0.5. 4.1.2 Apply TPrefixSpan algorithm: To mine the frequent "
94 38 "efi" "patterns we are applying existing TPrefixSpan algorithm proposed by Wu and Chen "
94 58 "rop" "patterns we are applying existing TPrefixSpan algorithm proposed by Wu and Chen "
94 35 "tpre" "patterns we are applying existing TPrefixSpan algorithm proposed by Wu and Chen "
95 9 "efi" "[8]. TPrefixSpan algorithm is the pattern mining algorithm to find maximum number "
95 6 "tpre" "[8]. TPrefixSpan algorithm is the pattern mining algorithm to find maximum number "
96 66 "s a" "of frequent patterns from interval based events. 4.1.3 Constraints added: After "
96 47 "s." "of frequent patterns from interval based events. 4.1.3 Constraints added: After "
97 13 "efi" "applying TPrefixSpan algorithm the multiple constraints like item, length and "
97 10 "tpre" "applying TPrefixSpan algorithm the multiple constraints like item, length and "
98 37 "efi" "aggregate constraints are added to refine the result according to user¡¦s interest. The "
98 21 "s a" "aggregate constraints are added to refine the result according to user¡¦s interest. The "
99 19 "s a" "various constraints added in our paper are explained below: Item Constraints: An "
100 21 "efi" "item constraint is defined as the subset of items that should or should not be present "
102 66 "s a" "market, a user may be interested in the patterns that have details about the day high "
103 40 "s a" "price. The patterns that contain details about the day high are considered as "
104 20 "s." "interesting patterns. This enhances the effectiveness of the algorithm by providing "
105 8 "s a" "patterns according to user¡¦s interest. Length Constraints: A length constraint specifies "
107 57 "ion" "number of occurrences of items or the number of transactions [10]. For example, a "
108 81 "s." "user may want to find longer patterns (i.e., at least 4 prices) in stock analysis. Such a "
111 62 "ion" "an aggregate of items in a pattern, where the aggregate function can be sum, "
112 35 "ion" "average, max, min, standard deviation [10]. For example, a user may want to find the "
114 27 "efi" "is over 3. By applying TPrefixSpan algorithm the frequent patterns mined are shown "
114 24 "tpre" "is over 3. By applying TPrefixSpan algorithm the frequent patterns mined are shown "
115 77 "s a" "in Figure 2. After applying Length constraint the resulting frequent patterns are "
116 35 "efi" "shown in Figure 3. Algorithm: CTPrefixSpan () Input: Temporal Sequence Database S. "
116 81 "s." "shown in Figure 3. Algorithm: CTPrefixSpan () Input: Temporal Sequence Database S. "
116 54 "temp" "shown in Figure 3. Algorithm: CTPrefixSpan () Input: Temporal Sequence Database S. "
116 32 "tpre" "shown in Figure 3. Algorithm: CTPrefixSpan () Input: Temporal Sequence Database S. "
118 56 "s." "Begin Step 1: Identify frequent temporal 1-patterns in S. Considering the frequent "
118 33 "temp" "Begin Step 1: Identify frequent temporal 1-patterns in S. Considering the frequent "
119 1 "temp" "temporal 1-pattern generated identify the projected database. Step 2: Generate "
120 48 "efi" "frequent patterns with frequent 1-pattern as prefix. Identify the projected database. "
121 60 "s a" "Repeat Step 1 and 2 until all the frequent temporal patterns are mined. Get the "
121 44 "temp" "Repeat Step 1 and 2 until all the frequent temporal patterns are mined. Get the "
125 12 "s a" "specified is aggregate constraint then Identify the patterns that matches the "
127 31 "efi" "End . Result Analysis Our CTPrefixSpan algorithm improves the efficiency and "
127 28 "tpre" "End . Result Analysis Our CTPrefixSpan algorithm improves the efficiency and "
128 61 "s." "effectiveness than other sequential pattern mining algorithms. The runtime and "
129 22 "efi" "Precision of both TPrefixSpan and CTPrefixSpan can be analysed by using medical or "
129 39 "efi" "Precision of both TPrefixSpan and CTPrefixSpan can be analysed by using medical or "
129 7 "ion" "Precision of both TPrefixSpan and CTPrefixSpan can be analysed by using medical or "
129 19 "tpre" "Precision of both TPrefixSpan and CTPrefixSpan can be analysed by using medical or "
129 36 "tpre" "Precision of both TPrefixSpan and CTPrefixSpan can be analysed by using medical or "
130 16 "s." "finance datasets. Though our algorithm increases the runtime, the precision rate of "
130 73 "ion" "finance datasets. Though our algorithm increases the runtime, the precision rate of "
131 18 "efi" "the proposed CTPrefixSpan algorithm is almost equal to 1. 5.1 Performance "
131 6 "rop" "the proposed CTPrefixSpan algorithm is almost equal to 1. 5.1 Performance "
131 38 "s a" "the proposed CTPrefixSpan algorithm is almost equal to 1. 5.1 Performance "
131 15 "tpre" "the proposed CTPrefixSpan algorithm is almost equal to 1. 5.1 Performance "
132 51 "efi" "Evaluation To evaluate the performance of our CTPrefixSpan, we implemented the "
132 8 "ion" "Evaluation To evaluate the performance of our CTPrefixSpan, we implemented the "
132 48 "tpre" "Evaluation To evaluate the performance of our CTPrefixSpan, we implemented the "
133 4 "efi" "TPrefixSpan algorithm for comparison. Both these algorithms were implemented "
133 1 "tpre" "TPrefixSpan algorithm for comparison. Both these algorithms were implemented "
135 58 "s a" "Visual Studio package. The runtime of these two algorithms are compared with "
136 35 "s." "different length of output patterns. Finally, we calculated the Precision rate of "
136 71 "ion" "different length of output patterns. Finally, we calculated the Precision rate of "
137 4 "efi" "TPrefixSpan and CTPrefixSpan algorithms with different data sets. Finally, it was "
137 21 "efi" "TPrefixSpan and CTPrefixSpan algorithms with different data sets. Finally, it was "
137 64 "s." "TPrefixSpan and CTPrefixSpan algorithms with different data sets. Finally, it was "
137 1 "tpre" "TPrefixSpan and CTPrefixSpan algorithms with different data sets. Finally, it was "
137 18 "tpre" "TPrefixSpan and CTPrefixSpan algorithms with different data sets. Finally, it was "
138 73 "s a" "found that our algorithm increases the runtime. But the precision rate is always "
138 63 "ion" "found that our algorithm increases the runtime. But the precision rate is always "
139 55 "ion" "nearest to value 1. 5.2 Runtime Comparisons The precision value is calculated by "
140 67 "efi" "using relevant patterns and retrieved patterns with respect to TPrefixSpan and "
140 23 "s a" "using relevant patterns and retrieved patterns with respect to TPrefixSpan and "
140 64 "tpre" "using relevant patterns and retrieved patterns with respect to TPrefixSpan and "
141 5 "efi" "CTPrefixSpan algorithms. After calculating the precision it is found that our "
141 23 "s." "CTPrefixSpan algorithms. After calculating the precision it is found that our "
141 54 "ion" "CTPrefixSpan algorithms. After calculating the precision it is found that our "
141 2 "tpre" "CTPrefixSpan algorithms. After calculating the precision it is found that our "
142 5 "efi" "CTPrefixSpan algorithm has a precision rate of 1. Finally it can be concluded that "
142 26 "s a" "CTPrefixSpan algorithm has a precision rate of 1. Finally it can be concluded that "
142 36 "ion" "CTPrefixSpan algorithm has a precision rate of 1. Finally it can be concluded that "
142 2 "tpre" "CTPrefixSpan algorithm has a precision rate of 1. Finally it can be concluded that "
143 36 "efi" "after applying constraints with TPrefixSpan the runtime may increase but the "
143 33 "tpre" "after applying constraints with TPrefixSpan the runtime may increase but the "
144 69 "efi" "precision rate of the proposed algorithm is high. 6. CONCLUSIONS TPrefixSpan "
144 24 "rop" "precision rate of the proposed algorithm is high. 6. CONCLUSIONS TPrefixSpan "
144 7 "ion" "precision rate of the proposed algorithm is high. 6. CONCLUSIONS TPrefixSpan "
144 61 "ion" "precision rate of the proposed algorithm is high. 6. CONCLUSIONS TPrefixSpan "
144 66 "tpre" "precision rate of the proposed algorithm is high. 6. CONCLUSIONS TPrefixSpan "
146 34 "s." "representing interval-based events. It is the most efficient interval based algorithms "
147 46 "s." "among the sequential pattern mining algorithms. Adding multiple constraints like "
149 46 "efi" "increases the efficiency of the proposed CTPrefixSpan algorithm. Authors M. "
149 34 "rop" "increases the efficiency of the proposed CTPrefixSpan algorithm. Authors M. "
149 43 "tpre" "increases the efficiency of the proposed CTPrefixSpan algorithm. Authors M. "
150 12 "s a" "Kalaivany is a student of M.Tech (Network and Internet Engineering) in the "
152 38 "s a" "Pondicherry University, India. She was awarded the Anna University for B.Tech degree "
154 73 "s a" "Engineering. She has published 1 research paper in international journals and in the "
154 60 "ion" "Engineering. She has published 1 research paper in international journals and in the "
155 69 "s a" "proceedings of various international conferences. V.Uma is working as Assistant "
155 48 "s." "proceedings of various international conferences. V.Uma is working as Assistant "
155 32 "ion" "proceedings of various international conferences. V.Uma is working as Assistant "
157 50 "s a" "Technology, Pondicherry University, India. She was awarded the Pondicherry "
158 72 "s." "University gold medal for M.Tech degree in Distributed Computing Systems. She is "
159 35 "temp" "pursuing her Ph.D in the field of Temporal knowledge representation. Her research "
159 65 "ion" "pursuing her Ph.D in the field of Temporal knowledge representation. Her research "
161 33 "s a" "in various international journals and in the proceedings of various international "
161 20 "ion" "in various international journals and in the proceedings of various international "
161 77 "ion" "in various international journals and in the proceedings of various international "
162 11 "s." "conferences.  "
163 54 "s a" "Abstract¡XThe mining of closed sequential patterns has attracted researchers for its "
165 8 "ion" "conventional mining. However, existing studies only focus on time point-based data. "
168 76 "s a" "closed time intervalbased patterns, also called closed temporal patterns, is an "
168 56 "temp" "closed time intervalbased patterns, also called closed temporal patterns, is an "
169 41 "ion" "arduous problem since the pairwise relationships between two interval-based events "
171 20 "temp" "to discover closed temporal patterns from interval-based data. Algorithm CEMiner "
172 23 "ion" "employs some optimization techniques to effectively reduce the search space. The "
175 7 "ion" "execution time but also possesses graceful scalability. The experiment conducted on "
177 18 "temp" "Keywords- closed temporal pattern; endpoint representation; sequential pattern "
177 56 "ion" "Keywords- closed temporal pattern; endpoint representation; sequential pattern "
178 43 "ion" "mining; time interval-based data INTRODUCTION Recently, sequential pattern mining "
179 2 "s a" "is an active research topic in data mining for its wide applications such as customer "
179 65 "ion" "is an active research topic in data mining for its wide applications such as customer "
180 25 "ion" "analysis, network intrusion detection, discovery of tandem repeats in DNA sequences, "
180 35 "ion" "analysis, network intrusion detection, discovery of tandem repeats in DNA sequences, "
182 24 "rop" "4, 9, 10, 15, 16, 22] proposed so far have good performance for discovering "
183 30 "s." "complete-set frequent patterns. But when mining long frequent sequences, or when "
189 37 "s a" "since all the other frequent patterns and their supports can be derived from this "
190 64 "s a" "pattern. Undoubtedly, a long sequential pattern usually contains an explosive "
191 22 "s a" "number of subsequences and using low support threshold often bears huge number "
192 15 "s." "of computations. When a user or an application only needs the longest or more "
192 12 "ion" "of computations. When a user or an application only needs the longest or more "
192 44 "ion" "of computations. When a user or an application only needs the longest or more "
194 74 "s a" "alternative. We can avoid exhaustive enumeration of all frequent sequences and thus "
194 46 "ion" "alternative. We can avoid exhaustive enumeration of all frequent sequences and thus "
203 51 "s." "sequence of events with both start and finish times. Examples include library lending, "
204 15 "ion" "stock fluctuations, patient diseases, and meteorology data. Actually, discovering "
206 8 "s." "patterns. For example, in the medical field, the simple ordered sequence of events "
207 62 "s a" "such as may be inadequate to express the complex relationships among symptoms. If "
207 77 "s." "such as may be inadequate to express the complex relationships among symptoms. If "
207 55 "ion" "such as may be inadequate to express the complex relationships among symptoms. If "
208 22 "ion" "we consider the duration time of events, some relationships can be mined from "
208 52 "ion" "we consider the duration time of events, some relationships can be mined from "
209 75 "s a" "clinical records of patients to study the correlations between the symptoms and the "
209 51 "ion" "clinical records of patients to study the correlations between the symptoms and the "
210 48 "s a" "diseases, or the influences between the diseases and other diseases. One may find "
210 67 "s." "diseases, or the influences between the diseases and other diseases. One may find "
211 41 "ion" "that ¡§in the case of myocardial infarction, chest pain usually contains the cardiac "
214 22 "s a" "point-based approaches are hampered by the fact that they can only handle "
215 53 "s." "instantaneous events efficiently, not event intervals. We can perceive that time "
218 38 "temp" "patterns (also referred to as closed temporal patterns) is more complex and arduous, "
219 12 "s a" "and requires a different approach from mining time point-based data. So far, little "
221 8 "s." "patterns. This is partly because of the complicated relationship among event "
221 58 "ion" "patterns. This is partly because of the complicated relationship among event "
222 9 "s." "intervals. Since the feature of time interval is quite different from time point, the "
223 74 "s a" "pairwise relationships between any two time interval-based 2011 11t events are "
223 15 "ion" "pairwise relationships between any two time interval-based 2011 11t events are "
224 42 "ion" "intrinsically complex. This complex relation is really a crucial bottleneck when we "
225 75 "temp" "endeavor to design an efficient and effective algorithm for mining closed temporal "
226 34 "ion" "patterns, since the complex relations may lead to generate larger number of "
227 19 "s a" "candidate sequences and workload for counting the support of a candidate sequence. "
228 13 "temp" "Allen¡¦s 13 temporal logics [2] are comprehensively used to describe the relations "
228 79 "ion" "Allen¡¦s 13 temporal logics [2] are comprehensively used to describe the relations "
230 36 "temp" "the finish endpoints, there are 13 temporal relations between any two event "
230 50 "ion" "the finish endpoints, there are 13 temporal relations between any two event "
231 9 "s a" "intervals as: ¡§before,¡¨ ¡§after,¡¨ ¡§overlap,¡¨ ¡§overlapped by,¡¨ ¡§contain,¡¨ ¡§during,¡¨ ¡§start,¡¨ "
233 15 "s a" "Allen¡¦s logics are binary relation and may suffer several problems when describing "
233 33 "ion" "Allen¡¦s logics are binary relation and may suffer several problems when describing "
234 60 "rop" "relationships among more than three event intervals. An appropriate representation "
234 13 "s a" "relationships among more than three event intervals. An appropriate representation "
234 51 "s." "relationships among more than three event intervals. An appropriate representation "
234 6 "ion" "relationships among more than three event intervals. An appropriate representation "
234 80 "ion" "relationships among more than three event intervals. An appropriate representation "
235 66 "ion" "is very crucial for facing this circumstance. Various representations [5, 6, 8, 11, 12, 14, "
236 16 "rop" "19] have been proposed but most of them have restriction on either ambiguity or "
236 54 "ion" "19] have been proposed but most of them have restriction on either ambiguity or "
237 27 "ion" "scalability. The contributions of this paper are as follow: We simplify the processing "
238 20 "s a" "of complex relations among intervals by capturing the global information of all "
238 17 "ion" "of complex relations among intervals by capturing the global information of all "
238 70 "ion" "of complex relations among intervals by capturing the global information of all "
239 58 "ion" "endpoints in a sequence. Comparing with the complex relations between intervals, "
240 13 "s a" "the relations among endpoints are simple, i.e., only ¡§before,¡¨ ¡§after¡¨ and ¡§equal.¡¨ "
240 29 "s a" "the relations among endpoints are simple, i.e., only ¡§before,¡¨ ¡§after¡¨ and ¡§equal.¡¨ "
240 10 "ion" "the relations among endpoints are simple, i.e., only ¡§before,¡¨ ¡§after¡¨ and ¡§equal.¡¨ "
241 29 "ion" "Various existing representations may lead to different kinds of problem. We develop "
242 61 "s a" "a compact representation, endpoint representation, to express a pattern or sequence "
242 22 "ion" "a compact representation, endpoint representation, to express a pattern or sequence "
242 47 "ion" "a compact representation, endpoint representation, to express a pattern or sequence "
243 66 "s a" "nonambiguously. Endpoint representation can facilitate the process and improve the "
243 37 "ion" "nonambiguously. Endpoint representation can facilitate the process and improve the "
245 30 "rop" "Endpoint Temporal Miner, is proposed to discover closed temporal patterns "
245 10 "temp" "Endpoint Temporal Miner, is proposed to discover closed temporal patterns "
245 57 "temp" "Endpoint Temporal Miner, is proposed to discover closed temporal patterns "
246 73 "ion" "efficiently and effectively. Furthermore, CEMiner employs some optimization "
248 17 "ion" "database projection. Experimental studies on both synthetic and real datasets "
249 16 "rop" "indicate that proposed strategy and algorithm are both efficient and scalable and "
250 56 "s a" "outperforms state-of-the-art algorithms. Our experiments also show that the "
250 39 "s." "outperforms state-of-the-art algorithms. Our experiments also show that the "
251 2 "rop" "proposed approach consumes a much smaller memory space. The remainder of this "
251 26 "s a" "proposed approach consumes a much smaller memory space. The remainder of this "
252 29 "s." "paper is organized as follows. Section 2 and 3 provide the related work and some "
252 36 "ion" "paper is organized as follows. Section 2 and 3 provide the related work and some "
253 34 "ion" "preliminaries, respectively. Section 4 introduces the endpoint representation. Section "
253 75 "ion" "preliminaries, respectively. Section 4 introduces the endpoint representation. Section "
253 84 "ion" "preliminaries, respectively. Section 4 introduces the endpoint representation. Section "
254 66 "s a" "5 describes the CEMiner algorithm. Section 6 gives the experiments and performance "
254 40 "ion" "5 describes the CEMiner algorithm. Section 6 gives the experiments and performance "
255 31 "ion" "study, and we conclude in Section 7 2.1 Closed Sequential Pattern Mining CloSpan "
257 12 "s a" "It generates a set of closed sequence candidates and then do post-pruning to "
257 48 "s a" "It generates a set of closed sequence candidates and then do post-pruning to "
258 35 "s." "discover closed sequential patterns. Although it performs two pruning methods to "
260 40 "s a" "closed sequence candidates. BIDE [17] is a fast algorithm for mining closed "
260 26 "s." "closed sequence candidates. BIDE [17] is a fast algorithm for mining closed "
261 52 "s a" "sequential patterns. Different from CloSpan, it uses a sequence closure checking "
261 19 "s." "sequential patterns. Different from CloSpan, it uses a sequence closure checking "
262 68 "rop" "scheme to avoid the maintenance of closed candidate sequence. The Proposed "
264 37 "s a" "methods used in CloSpan. COBRA [7] is a two-phased mining algorithm. It first finds "
266 24 "s." "frequent closed itemsets. Because COBRA uses both vertical and horizontal database "
267 75 "s a" "formats to reduce the searching time in mining process, the memory usage is a major "
268 27 "temp" "problem. 2.2 Complete-set Temporal Pattern Mining Some recent works have "
269 57 "s." "investigated the mining of complete-set temporal patterns. Kam et al. [8] designed "
269 41 "temp" "investigated the mining of complete-set temporal patterns. Kam et al. [8] designed "
270 84 "s." "an algorithm that uses the hierarchical representation to discover temporal patterns. "
270 68 "temp" "an algorithm that uses the hierarchical representation to discover temporal patterns. "
270 52 "ion" "an algorithm that uses the hierarchical representation to discover temporal patterns. "
271 43 "s a" "However, the hierarchical representation is ambiguous and many spurious patterns "
271 53 "s a" "However, the hierarchical representation is ambiguous and many spurious patterns "
271 38 "ion" "However, the hierarchical representation is ambiguous and many spurious patterns "
272 25 "efi" "are found. Hoppner [6] defined the supporting level of a pattern as the total time in "
275 11 "rop" "[13] was proposed to discovery frequent arrangements of event intervals. This "
275 71 "s." "[13] was proposed to discovery frequent arrangements of event intervals. This "
276 19 "s a" "approach transforms an event sequence into a vertical representation using id-lists. "
276 83 "s." "approach transforms an event sequence into a vertical representation using id-lists. "
276 66 "ion" "approach transforms an event sequence into a vertical representation using id-lists. "
277 75 "s." "Hence, H-DFS does not scale well when the temporal pattern length increases. TSKR "
277 43 "temp" "Hence, H-DFS does not scale well when the temporal pattern length increases. TSKR "
278 20 "temp" "[12] expressed the temporal concepts of coincidence and partial order for interval "
279 8 "s." "patterns. The pattern represented in this format is easily understandable but may "
280 17 "ion" "reveal the relationship between pairwise event intervals in a pattern ambiguously. "
281 51 "rop" "Based on MEMISP [9], an algorithm ARMADA [18] is proposed to find frequent "
282 43 "s a" "temporal patterns from large database. This approach only needs two database scans "
282 1 "temp" "temporal patterns from large database. This approach only needs two database scans "
283 39 "ion" "and does not require candidate generation or database projection. Wu et al. [19] "
283 62 "ion" "and does not require candidate generation or database projection. Wu et al. [19] "
284 68 "efi" "devised a nonambiguous expression, temporal representation, and TPrefixSpan "
284 36 "temp" "devised a nonambiguous expression, temporal representation, and TPrefixSpan "
284 31 "ion" "devised a nonambiguous expression, temporal representation, and TPrefixSpan "
284 56 "ion" "devised a nonambiguous expression, temporal representation, and TPrefixSpan "
284 65 "tpre" "devised a nonambiguous expression, temporal representation, and TPrefixSpan "
285 63 "s a" "algorithm to discover frequent temporal patterns. Although this algorithm only need "
285 48 "s." "algorithm to discover frequent temporal patterns. Although this algorithm only need "
285 32 "temp" "algorithm to discover frequent temporal patterns. Although this algorithm only need "
287 47 "ion" "search space. Patel et al. [14] utilized additional counting information to achieve a "
287 70 "ion" "search space. Patel et al. [14] utilized additional counting information to achieve a "
288 34 "ion" "lossless hierarchical representation, named Augmented Representation, and "
288 66 "ion" "lossless hierarchical representation, named Augmented Representation, and "
289 2 "rop" "proposed an algorithm, IEMiner. Although IEMiner uses some optimization strategies "
289 69 "ion" "proposed an algorithm, IEMiner. Although IEMiner uses some optimization strategies "
291 35 "s." "has to scan database multiple times. HTPM [20] was developed for mining hybrid "
292 1 "temp" "temporal patterns from event sequences, which contain both point-based and "
293 21 "s." "interval-based events. A new robust representation, SIPO [11], utilizes the "
293 48 "ion" "interval-based events. A new robust representation, SIPO [11], utilizes the "
295 13 "s a" "relationships among intervals. The mining algorithm requires discovering both closed "
295 29 "s." "relationships among intervals. The mining algorithm requires discovering both closed "
295 6 "ion" "relationships among intervals. The mining algorithm requires discovering both closed "
296 70 "ion" "sequential pattern and closed itemset. Based on a compact representation, "
297 42 "s a" "coincidence representation, CTMiner [5] is an efficient algorithm for mining temporal "
297 78 "temp" "coincidence representation, CTMiner [5] is an efficient algorithm for mining temporal "
297 24 "ion" "coincidence representation, CTMiner [5] is an efficient algorithm for mining temporal "
298 27 "rop" "patterns. Algorithm also proposed some pruning strategies to significantly reduce the "
298 8 "s." "patterns. Algorithm also proposed some pruning strategies to significantly reduce the "
300 38 "temp" "from time point-based data or mining temporal patterns from time interval-based "
301 82 "s a" "data. No effort has been put to closed temporal pattern. In this paper, we discuss and "
301 40 "temp" "data. No effort has been put to closed temporal pattern. In this paper, we discuss and "
302 47 "temp" "design an efficient method to discover closed temporal patterns from interval-based "
305 6 "ion" "relation among event intervals is intrinsically more complicated than that of the "
306 12 "s." "event points. Allen¡¦s 13 temporal logics [2], in general, are adopted to describe the "
306 27 "temp" "event points. Allen¡¦s 13 temporal logics [2], in general, are adopted to describe the "
307 9 "s a" "relations among intervals, as shown in Fig. 1. Unfortunately, when describing "
307 6 "ion" "relations among intervals, as shown in Fig. 1. Unfortunately, when describing "
308 13 "s a" "relationships among more than three events, Allen¡¦s temporal logics may suffer "
308 54 "temp" "relationships among more than three events, Allen¡¦s temporal logics may suffer "
308 6 "ion" "relationships among more than three events, Allen¡¦s temporal logics may suffer "
309 16 "s." "several problems. A suitable representation is very important for describing a "
309 41 "ion" "several problems. A suitable representation is very important for describing a "
310 74 "rop" "temporal pattern. As mentioned above, various representations have been proposed "
310 1 "temp" "temporal pattern. As mentioned above, various representations have been proposed "
310 26 "ion" "temporal pattern. As mentioned above, various representations have been proposed "
310 58 "ion" "temporal pattern. As mentioned above, various representations have been proposed "
311 31 "ion" "but most of them have restriction on either ambiguity or space usage. In this paper, a "
312 45 "rop" "new expression, endpoint representation is proposed to address the ambiguous and "
312 76 "s a" "new expression, endpoint representation is proposed to address the ambiguous and "
312 12 "ion" "new expression, endpoint representation is proposed to address the ambiguous and "
312 37 "ion" "new expression, endpoint representation is proposed to address the ambiguous and "
313 28 "temp" "scalable problem. Existing temporal pattern mining assumes that events do not have "
314 10 "ion" "any duration. However, events in many real world applications have durations, and "
314 58 "ion" "any duration. However, events in many real world applications have durations, and "
314 73 "ion" "any duration. However, events in many real world applications have durations, and "
315 17 "s a" "the relationships among these events are often complex. These relationships are "
315 36 "s a" "the relationships among these events are often complex. These relationships are "
315 75 "s a" "the relationships among these events are often complex. These relationships are "
315 10 "ion" "the relationships among these events are often complex. These relationships are "
315 68 "ion" "the relationships among these events are often complex. These relationships are "
316 56 "s a" "modeled using a hierarchical representation that extends Allen¡¦s interval algebra. "
316 41 "ion" "modeled using a hierarchical representation that extends Allen¡¦s interval algebra. "
317 64 "s a" "However, this representation is lossy as the exact relationships among the events "
317 26 "ion" "However, this representation is lossy as the exact relationships among the events "
317 57 "ion" "However, this representation is lossy as the exact relationships among the events "
318 82 "ion" "cannot be fully recovered. In this paper, we augment the hierarchical representation "
319 11 "ion" "with additional information to achieve a lossless representation. An efficient "
319 25 "ion" "with additional information to achieve a lossless representation. An efficient "
319 62 "ion" "with additional information to achieve a lossless representation. An efficient "
320 59 "temp" "algorithm called IEMiner is designed to discover frequent temporal patterns from "
321 21 "s." "interval-based events. The algorithm employs two optimization techniques to reduce "
321 59 "ion" "interval-based events. The algorithm employs two optimization techniques to reduce "
322 52 "s." "the search space and remove non-promising candidates. From the discovered "
323 1 "temp" "temporal patterns, we build an interval-based classifier called IEClassifier to "
324 37 "s." "differentiate closely related classes. Experiments on both synthetic and real world "
325 58 "rop" "datasets indicate the efficiency and scalability of the proposed approach, as well as "
326 52 "s a" "the improved accuracy of IEClassifier. General Terms Algorithms Keywords "
327 30 "temp" "Interval-based Event Mining, Temporal Relation, Classifier for Interval Data 1. "
327 44 "ion" "Interval-based Event Mining, Temporal Relation, Classifier for Interval Data 1. "
328 14 "temp" "INTRODUCTION Temporal pattern mining aims to discover useful relations that are "
328 10 "ion" "INTRODUCTION Temporal pattern mining aims to discover useful relations that are "
328 67 "ion" "INTRODUCTION Temporal pattern mining aims to discover useful relations that are "
329 19 "s." "hidden among events. Existing temporal mining algorithms [1, 10, 3, 12] have "
329 31 "temp" "hidden among events. Existing temporal mining algorithms [1, 10, 3, 12] have "
330 33 "temp" "focused on discovering frequent temporal patterns from instantaneous events, that "
331 33 "s a" "is, events with no duration. This assumption allows the discovered pattern to be "
331 25 "ion" "is, events with no duration. This assumption allows the discovered pattern to be "
331 42 "ion" "is, events with no duration. This assumption allows the discovered pattern to be "
333 8 "s a" "patterns are inadequate to express the complex temporal relationships in domains "
333 48 "temp" "patterns are inadequate to express the complex temporal relationships in domains "
333 62 "ion" "patterns are inadequate to express the complex temporal relationships in domains "
334 78 "ion" "such as medical, multimedia, meteorology and finance where the events¡¦ durations "
337 87 "s." "glycosuria2. This insight has led to the development of effective diabetic testing kits. "
340 26 "s a" "disease. Clearly, there is a need for an efficient mining algorithm that can discover "
341 21 "s a" "complex relationships among events with duration, also known as interval-based "
341 14 "ion" "complex relationships among events with duration, also known as interval-based "
341 46 "ion" "complex relationships among events with duration, also known as interval-based "
342 6 "s." "events. Furthermore, these discovered relationships could be used to build a "
342 44 "ion" "events. Furthermore, these discovered relationships could be used to build a "
343 18 "s a" "classifier that is able to distinguish closely related classes. Mining complex "
343 62 "s." "classifier that is able to distinguish closely related classes. Mining complex "
344 49 "s a" "interval-based relationships efficiently requires an unique yet lossless representation "
344 21 "ion" "interval-based relationships efficiently requires an unique yet lossless representation "
344 85 "ion" "interval-based relationships efficiently requires an unique yet lossless representation "
345 37 "s a" "to capture the temporal relationships among events. Allen¡¦s interval algebra [2] has "
345 50 "s." "to capture the temporal relationships among events. Allen¡¦s interval algebra [2] has "
345 16 "temp" "to capture the temporal relationships among events. Allen¡¦s interval algebra [2] has "
345 30 "ion" "to capture the temporal relationships among events. Allen¡¦s interval algebra [2] has "
346 42 "temp" "traditionally been used to represent the temporal relationship between two "
346 7 "ion" "traditionally been used to represent the temporal relationship between two "
346 56 "ion" "traditionally been used to represent the temporal relationship between two "
347 68 "s a" "interval-based events. However, capturing the temporal relationships among three or "
347 21 "s." "interval-based events. However, capturing the temporal relationships among three or "
347 47 "temp" "interval-based events. However, capturing the temporal relationships among three or "
347 61 "ion" "interval-based events. However, capturing the temporal relationships among three or "
348 19 "s a" "more events remains an issue. Many approaches use a hierarchical representation [6, "
348 77 "ion" "more events remains an issue. Many approaches use a hierarchical representation [6, "
349 40 "s a" "14] to encode the temporal relationships among events. This representation is lossy "
349 53 "s." "14] to encode the temporal relationships among events. This representation is lossy "
349 19 "temp" "14] to encode the temporal relationships among events. This representation is lossy "
349 33 "ion" "14] to encode the temporal relationships among events. This representation is lossy "
349 72 "ion" "14] to encode the temporal relationships among events. This representation is lossy "
350 71 "s." "as it does not preserve the underlying temporal structure of the events. Any mining "
350 40 "temp" "as it does not preserve the underlying temporal structure of the events. Any mining "
351 47 "ion" "algorithm that is based on a lossy representation will lead to the discovery of many "
352 17 "s a" "spurious patterns as non-frequent patterns may become frequent. Existing "
353 32 "s a" "interval-based mining algorithms are either based on a lossy representation [8] or do "
353 73 "ion" "interval-based mining algorithms are either based on a lossy representation [8] or do "
355 31 "rop" "representation. Based on the proposed representation, we design an interval-based "
355 12 "ion" "representation. Based on the proposed representation, we design an interval-based "
355 50 "ion" "representation. Based on the proposed representation, we design an interval-based "
356 60 "ion" "event mining algorithm. The algorithm employs two optimization techniques to "
357 59 "s." "reduce the search space and remove non-promising candidates. Taking a step further, "
358 31 "temp" "we examine how the discovered temporal patterns can be utilized in classification to "
358 79 "ion" "we examine how the discovered temporal patterns can be utilized in classification to "
359 37 "s." "differentiate closely related classes. To the best of our knowledge, this is the first "
360 58 "ion" "work to build an interval-based classifier. The contributions of this paper are as "
361 48 "ion" "follow: We augment the hierarchical representation with count information to "
361 71 "ion" "follow: We augment the hierarchical representation with count information to "
362 31 "ion" "achieve a lossless representation. We provide a proof that the augmented "
363 33 "s." "representation is indeed lossless. This enables us to recover the actual relationships "
363 12 "ion" "representation is indeed lossless. This enables us to recover the actual relationships "
363 79 "ion" "representation is indeed lossless. This enables us to recover the actual relationships "
364 34 "s." "among events in the mining process. We design an Apriori-based algorithm called "
365 63 "temp" "¡§IEMiner¡¨( Interval-based Event Miner) to discover frequent temporal patterns based "
366 28 "ion" "on the lossless representation. IEMiner employs two optimization strategies to "
366 62 "ion" "on the lossless representation. IEMiner employs two optimization strategies to "
368 30 "temp" "also build an interval-based temporal pattern classifier called IEClassifier to perform "
369 45 "s." "the classification of closely related classes. We apply the classifier to a real world "
369 16 "ion" "the classification of closely related classes. We apply the classifier to a real world "
372 43 "s." "and outperforms state-of-the-art algorithms. The IEClassi- fier improves the "
373 68 "ion" "predictive accuracy on the real world Hepatitis dataset over traditional classifiers "
374 85 "s." "such as CBA [9], C4.5 [13] and SVM [5]. The rest of the paper is organized as follows. "
375 71 "s." "Section 2 gives the related work. Section 3 provides some preliminaries. Section 4 "
375 5 "ion" "Section 2 gives the related work. Section 3 provides some preliminaries. Section 4 "
375 39 "ion" "Section 2 gives the related work. Section 3 provides some preliminaries. Section 4 "
375 78 "ion" "Section 2 gives the related work. Section 3 provides some preliminaries. Section 4 "
376 56 "ion" "introduces the augmented hierarchical-based representation. Section 5 describes the "
376 65 "ion" "introduces the augmented hierarchical-based representation. Section 5 describes the "
377 49 "s." "IEMiner algorithm and the optimization strategies. Section 6 presents the design of "
377 36 "ion" "IEMiner algorithm and the optimization strategies. Section 6 presents the design of "
377 56 "ion" "IEMiner algorithm and the optimization strategies. Section 6 presents the design of "
378 52 "s a" "IEClassifier. Section 7 gives the experiment results and we conclude in Section 8 2. "
378 19 "ion" "IEClassifier. Section 7 gives the experiment results and we conclude in Section 8 2. "
378 77 "ion" "IEClassifier. Section 7 gives the experiment results and we conclude in Section 8 2. "
380 27 "s a" "[3, 12, 10, 1]. These works assume that events have zero duration. Recent works have "
380 63 "ion" "[3, 12, 10, 1]. These works assume that events have zero duration. Recent works have "
382 74 "temp" "algorithm that uses the hierarchical representation to discover frequent temporal "
382 49 "ion" "algorithm that uses the hierarchical representation to discover frequent temporal "
383 53 "s a" "patterns. However, the hierarchical representation is ambiguous and many spurious "
383 63 "s a" "patterns. However, the hierarchical representation is ambiguous and many spurious "
383 8 "s." "patterns. However, the hierarchical representation is ambiguous and many spurious "
383 48 "ion" "patterns. However, the hierarchical representation is ambiguous and many spurious "
384 46 "rop" "patterns are found. Papapetrou et. al. [11] propose the H-DFS algorithm to mine "
384 8 "s a" "patterns are found. Papapetrou et. al. [11] propose the H-DFS algorithm to mine "
384 61 "s a" "patterns are found. Papapetrou et. al. [11] propose the H-DFS algorithm to mine "
385 43 "s." "frequent arrangements of temporal intervals. Both these works transform an event "
385 26 "temp" "frequent arrangements of temporal intervals. Both these works transform an event "
386 54 "s." "sequence into a vertical representation using id-lists. The id-list of one event is "
386 37 "ion" "sequence into a vertical representation using id-lists. The id-list of one event is "
387 75 "s a" "merged with the id-list of other events to generate temporal patterns. This approach "
387 69 "s." "merged with the id-list of other events to generate temporal patterns. This approach "
387 53 "temp" "merged with the id-list of other events to generate temporal patterns. This approach "
388 62 "s." "does not scale well when the temporal pattern length increases. Wu et. al. [15] "
388 30 "temp" "does not scale well when the temporal pattern length increases. Wu et. al. [15] "
389 31 "efi" "devise an algorithm called TPrefix for mining non-ambiguous temporal pattern from "
389 61 "temp" "devise an algorithm called TPrefix for mining non-ambiguous temporal pattern from "
389 28 "tpre" "devise an algorithm called TPrefix for mining non-ambiguous temporal pattern from "
390 27 "efi" "interval-based events. TPrefix first discovers single frequent events from the "
390 21 "s." "interval-based events. TPrefix first discovers single frequent events from the "
390 24 "tpre" "interval-based events. TPrefix first discovers single frequent events from the "
391 38 "s a" "projected database. Next, it generates all the possible candidates between temporal "
391 76 "temp" "projected database. Next, it generates all the possible candidates between temporal "
392 3 "efi" "prefix and discovered frequent events and scans the projected database again for "
392 37 "s a" "prefix and discovered frequent events and scans the projected database again for "
393 22 "efi" "support counting. TPrefixSpan has several inherent limitations: multiple scans of the "
393 59 "ion" "support counting. TPrefixSpan has several inherent limitations: multiple scans of the "
393 19 "tpre" "support counting. TPrefixSpan has several inherent limitations: multiple scans of the "
396 79 "rop" "high confidence association rules useful for classification. Liu et. al. [9] propose a "
396 25 "ion" "high confidence association rules useful for classification. Liu et. al. [9] propose a "
396 57 "ion" "high confidence association rules useful for classification. Liu et. al. [9] propose a "
397 12 "ion" "classification scheme based on association rules to improve the prediction accuracy. "
397 40 "ion" "classification scheme based on association rules to improve the prediction accuracy. "
397 72 "ion" "classification scheme based on association rules to improve the prediction accuracy. "
399 72 "s a" "classification. In their approach, high discriminating frequent patterns are discovered "
399 12 "ion" "classification. In their approach, high discriminating frequent patterns are discovered "
400 44 "s a" "from the non-sequential data. These patterns are used as additional features for "
400 56 "s a" "from the non-sequential data. These patterns are used as additional features for "
400 63 "ion" "from the non-sequential data. These patterns are used as additional features for "
401 12 "ion" "classification. In our approach, we discover discriminative frequent patterns from "
402 48 "ion" "sequential data and employ them for classification. In this paper, we have examined "
403 35 "s a" "the problem of mining relationships among interval-based events. We augmented "
403 63 "s." "the problem of mining relationships among interval-based events. We augmented "
403 28 "ion" "the problem of mining relationships among interval-based events. We augmented "
404 34 "ion" "existing hierarchical representation with additional count information to make the "
404 48 "ion" "existing hierarchical representation with additional count information to make the "
404 68 "ion" "existing hierarchical representation with additional count information to make the "
405 23 "s." "representation lossless. Based on this new representation, we have developed an "
405 12 "ion" "representation lossless. Based on this new representation, we have developed an "
405 55 "ion" "representation lossless. Based on this new representation, we have developed an "
406 50 "temp" "Apriori-based IEMiner algorithm to mine frequent temporal patterns from "
407 21 "s." "interval-based events. We designed an efficient support counting procedure. The "
409 18 "efi" "strategy and a prefix counting strategy. Experiments on synthetic data sets and real "
409 75 "s a" "strategy and a prefix counting strategy. Experiments on synthetic data sets and real "
410 67 "rop" "world datasets demonstrate the efficiency and scalability of our proposed approach. "
412 58 "s." "improve the predictive accuracy of closely related classes. Experiment results on the "
413 60 "ion" "Hepatitis dataset show that IEClassifier outperforms traditional classifiers such as "
418 72 "s." "(Hep-T). We observe that IEMiner perform best compared to all algorithms. Here, "
419 68 "efi" "average length of underlying event list is around 200 events. GenPrefixspan did not "
419 42 "s a" "average length of underlying event list is around 200 events. GenPrefixspan did not "
419 60 "s." "average length of underlying event list is around 200 events. GenPrefixspan did not "
420 63 "s a" "perform well because it consider events without duration and as a result many "
420 54 "ion" "perform well because it consider events without duration and as a result many "
421 8 "s a" "patterns are generated compared to other three algorithm. If the results of a test "
